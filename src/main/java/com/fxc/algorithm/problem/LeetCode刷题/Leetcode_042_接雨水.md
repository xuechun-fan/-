# Leetcode_042_接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
示例 2：

输入：height = [4,2,0,3,2,5]
输出：9

别人的思路都是高端的动态规划啥的，我实在是不想用动态规划，感觉用单调栈会更合适一点。

使用单调递减栈，类似于之前做过的寻找下一个更大元素类的题目。在这道题里呢，我们规定单调递减栈，如果遇到比栈顶更小的元素，我们则认为当前位置是可能会存雨水的，则将当前下标入栈；如果遇到更大的元素，意味着当前的这堵墙与前面的墙中间可以存多少水可以求出来了，我们就结算一下。详细见代码：

```java
public int trap(int[] nums){
    //	创建辅助栈，注意：栈内存放的是下标，而不是元素
    Stack<Integer> s = new Stack<>();
    int ans = 0;
    for(int i=0; i<nums.length; i++){
        //	单调栈的核心的地方，保证单调性
		while(!s.isEmpty() && nums[i]>nums[s.peek()]){
            //	如果遇到当前元素大于栈顶元素，则结算前面的雨水面积。
            //	此时 cur 指向的就是可以存雨水的下标
            int cur = s.pop();
            //	如果存雨水的下标位于第一位，那么左边没有墙，这种情况是没办法存雨水的，则跳过本次清算
            if(s.isEmpty()) continue;
            //	s.peek()就代表左边那堵墙的下标，通过当前的下标和左边墙的下标计算出距离
            int dis = i - s.peek() - 1;
            //	这里要提一下为什么要 减去 nums[cur]：这个其实就是用来解决多堵墙之间的存水问题。比如 3、2、0、1、4,这种情况在 2、0、1结算一次。然后还要再去结算外边墙的水，画个图就明白了，总的来说就是根据两墙水平分层计算雨水面积。
            ans += dis * (Math.min(nums[i], nums[s.peek()]) - nums[cur]);
        }
        s.push(i);
    }
    return ans;
}
```

